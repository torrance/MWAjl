var documenterSearchIndex = {"docs":
[{"location":"skymodel/#Sky-Model-1","page":"Sky Model","title":"Sky Model","text":"","category":"section"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"A sky model consists of one of more named sources. Each source consists of one or more emission components with properties that describe their respective position on the sky, type, and emission spectrum. This information can be used to describe both bright calibrator sources (like Cygnus A, for example) or an entire field of view of fainter, smaller, point sources. And either can be used as a model to obtain a calibration solution.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"This page describes the format used in sky model files, passed to calibrate using the --model parameter. This page also describes how some of these sky model parameters are interpreted and processed.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"Pages = [\"skymodel.md\"]\nDepth = 5","category":"page"},{"location":"skymodel/#skymodel-fileformat-1.1-1","page":"Sky Model","title":"skymodel fileformat 1.1","text":"","category":"section"},{"location":"skymodel/#Syntax-1","page":"Sky Model","title":"Syntax","text":"","category":"section"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"Keywords and tokens are required to be separated by white space (one more or of spaces, tabs, new lines), with the exception of braces ({ or }) which are understood as complete keywords.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"Single quotes (') or double quotes (\") can be used around a strings containing white space, for example in source names like \"Crab Nebula\" or 'Fornax A', so long as the opening and closing quotes match. There are no escape characters for within quoted strings.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"The format is otherwise not white-space sensitive: new lines, spaces and tabs can be used to format the file as desired.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"Comments are indicated by a # symbol and will exclude all proceeding text until the next new line from further processing.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"note: Note\nThe function gettoken() can be referenced for further clarity about token parsing.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"gettoken","category":"page"},{"location":"skymodel/#MWAjl.gettoken","page":"Sky Model","title":"MWAjl.gettoken","text":"gettoken(f::IOStream)::String\n\nParses the head of f::IOSteam and stops when a complete token has been parsed, which is returned. All tokens are lowercased on return.\n\nThis function has the side effect of advancing the position of the IOStream.\n\nTokens are defined as any whitespace (spaces, tabs, newlines, etc.) delimited text with two exceptions: both { and } are considered complete tokens and do not necessarily require surrounding white space; and any token begining with a quote (either ' or '') will only conclude upon reaching a matching quote character (which will be stripped from the token). There are no escape characters. Comments are indicated by a # symbol and will exclude all text to the right until the next new line.\n\n\n\n\n\n","category":"function"},{"location":"skymodel/#Format-1","page":"Sky Model","title":"Format","text":"","category":"section"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"The sky model file must include the following header as the first non-whitespace text:","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"skymodel fileformat 1.1","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"Following this, any number of sources may be provided:","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"source {\n    name \"Source name\"\n    component { ... } [component { ... }, ...]\n}","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"A source provides a representation of a radio object. For a typical point-like source on the sky, a source will have just one component. For larger or more complex sources, a source may have hundreds or even thousands of components.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"Each source must have a name, and optionally 0 or more components.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"component {\n    position 00h00m00.0s 00d00m00.0s\n    type {point | gaussian}\n    [shape 150 120 30]\n    [measurement {...}, ...] | sed{...}]\n}","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"A component describes emission originating from a single direction in the sky. Each component must have a position, a type and spectrum.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"The position describes the J2000 RA and Dec coordinates of the emission and must be in the sexagesimal format illustrated above, using the 'h', 'm' and 's' characters for RA and 'd', 'm', 's' for Dec. No other format is accepted.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"The type of the component can be a point source or a Gaussian. A point source is represented analytically in the measurement equation as a Dirac delta function.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"A gaussian source requires the additional parameter shape which describes the major and minor axis (arcseconds) and a position angle (degrees). ToDo: Which direction is the angle measured from?","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"Each component must also contain spectrum information. The spectrum describes the flux of the source as a function of frequency. This is provided in one of two ways: either as one or more measurements at specified frequencies, or as a spectral energy distrbution (SED).","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"A measurement is of the format:","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"measurement {\n  frequency 100 MHz\n  fluxdensity Jy 100 2 2 0\n}","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"The frequency field describes the frequency at which the meausurement was taken. The unit MHz must be appended, and this is the only unit currently accepted. Other units like GHz will throw an error.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"fluxdensity describes the measured flux of the component at the specified frequency in units of Jansky in Stokes I, Q, U, V, respectively. The unit Jy must be provided, and is the only unit currently accepted.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"note: Note\nThe flux density is the total/integrated flux of the source [Jy], not the peak flux [Jy / beam]. For point sources these values are identical, but for Gaussian sources they are not.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"note: Note\nSee below for the rules for how flux density is interpolated in frequency when using measurements.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"An SED is an alternative to providing one more more measurements. It allows for complete control over how the spectrum is interpolated in frequency by specifying arbitrary Taylor terms describing the curve:","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"log(S) = log(S_0) + alpha log(nu - nu_0) + beta log(nu - nu_0)^2 + ","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"The format for specifying an SED is as follows:","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"sed {\n  frequency 154 MHz\n  fluxdensity Jy 100 0 0 0\n  spectral-index { -0.7 [...] }\n}","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"The frequency field specifies the reference frequency nu_0. Only MHz is accepted.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"The fluxdensity specifies the flux density S_0 measured at the reference frequency in units of Jansky in Stokes I, Q, U, V, respectively. The unit Jy must be provided, and is the only unit currently accepted. The flux density is the total/integrated flux of the source.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"The spectral index describes the Taylor terms of the curve in log/log space, i.e. alpha, beta, etc. At least one Taylor term must be provided, however there is no limit to the number of coefficients that are accepted.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"note: Note\nThe SED curve applies to all of the Stokes parameters, and there is not currently any way to specify unique curves for each.","category":"page"},{"location":"skymodel/#Example-skymodels-1","page":"Sky Model","title":"Example skymodels","text":"","category":"section"},{"location":"skymodel/#A-single-point-source-with-measurements-1","page":"Sky Model","title":"A single point source with measurements","text":"","category":"section"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"skymodel fileformat 1.1\nsource {\n  name \"J035857+102702\"\n  component {\n    type point\n    position 03h58m57.7099s +10d27m17.892s\n    measurement {\n      frequency 80 MHz\n      fluxdensity Jy 46.75907 0 0 0\n    }\n    measurement {\n      frequency 100 MHz\n      fluxdensity Jy 39.73867 0 0 0\n    }\n    measurement {\n      frequency 120 MHz\n      fluxdensity Jy 34.80545 0 0 0\n    }\n  }\n}","category":"page"},{"location":"skymodel/#A-single-point-source-with-SED-1","page":"Sky Model","title":"A single point source with SED","text":"","category":"section"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"source {\n  name \"Crab\"\n  component {\n    type point\n    position 05h34m28.1s 22d02m09s\n    sed {\n      frequency 154 MHz\n      fluxdensity Jy 87.0601723 0 0 0\n      spectral-index { -0.22 0.00 }\n    }\n  }\n}","category":"page"},{"location":"skymodel/#A-multicomponent-source-with-mixed-component-types-1","page":"Sky Model","title":"A multicomponent source with mixed component types","text":"","category":"section"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"source {\n  name \"J232013-132102A\"\n  component {\n    type gaussian\n    position 23h20m10.1296s -13d19m47.316s\n    shape 185.821633 159.627594 -89.000000\n    sed {\n      frequency 154 MHz\n      fluxdensity Jy 87.0601723 0 0 0\n      spectral-index { -0.22 0.00 }\n    }\n  }\n  component {\n    type point\n    position 23h20m17.9149s -13d22m31.836s\n    measurement {\n      frequency 80 MHz\n      fluxdensity Jy 0.27617 0 0 0\n    }\n    measurement {\n      frequency 240 MHz\n      fluxdensity Jy 0.15225 0 0 0\n    }\n  }\n}","category":"page"},{"location":"skymodel/#Measurement-interpolation-rules-1","page":"Sky Model","title":"Measurement interpolation rules","text":"","category":"section"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"When specifying a component spectrum using measurements, it is usually necessary for calibrate to interpolate in frequency between the specified measurements. These rules follow exactly the rules used by the original claibrate, as well as handling all edge cases.","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"The rules for how this works are best described by the documentation of the implementing function:","category":"page"},{"location":"skymodel/#","page":"Sky Model","title":"Sky Model","text":"stokes","category":"page"},{"location":"skymodel/#MWAjl.stokes","page":"Sky Model","title":"MWAjl.stokes","text":"stokes(ms::Measurements, ν::Float64)\n\nGiven a Measurements object (containing one more more Measurement objects), interpolate each of Stokes I, Q, U, V to the frequency ν.\n\nThis function has been implemented to identically match the behaviour of the original calibrate.\n\nWe interpolate in three ways:\n\nIf just one measurement is provide, we assume a flat spectral index (i.e. constant).\nIf the frequency ν lies between two measured values, we linearly interpolate (in log/log space) between these values. EXCEPT if either of the two neighbour values is <= 0, then we linearly interpolate in linear space between the two neighbouring measurements.\nOtherwise, we linearly interpolate in log/log space based on a least squares fit to all  strictly positive measurements. If none are strictly positive, we return 0. If just one is strictly positive, the spectrum is assumed flat.\n\nwarning: Warning\nThere are plenty of pathological combinations of measurement values that will give unexpected results. For example, given measurements 100 MHz => 1 Jy and 200 MHz => 0 Jy, then requesting the flux density at 300 MHz will give 1 Jy.To avoid such unexpected results, ensure all measurements are strictly positive (i.e. > 0).Or for complete control over interpolation, it is recommended to instead provide an SED.\n\n\n\n\n\n","category":"function"},{"location":"#MWAjl-1","page":"MWAjl","title":"MWAjl","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"A Julia library for calibrating measurement sets produced by the Murchison Widefield Array (MWA).","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"This is a rewrite of the existing calibration software using a near-identical algorithm (known variously as 'Mitchcal' or 'Stefcal'), but optimised for speed and to take advantage of graphics processing units (GPUs) if available.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"Pages = [\"index.md\"]\nDepth = 5","category":"page"},{"location":"#Installation-1","page":"MWAjl","title":"Installation","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"The package has been tested in Julia 1.4 and can be installed from the Julia package manager. Start the Julia REPL and press ] to enter the package manager, then run add https://github.com/torrance/MWAjl, eg:","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"$ julia\njulia> ]\npkg> add https://github.com/torrance/MWAjl","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"There are additional build steps required to link against Casacore and the MWA beam.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"It is recommened to install PackageCompiler to ensure fast start-up times when using calibrate.jl.","category":"page"},{"location":"#Usage-1","page":"MWAjl","title":"Usage","text":"","category":"section"},{"location":"#Overview-1","page":"MWAjl","title":"Overview","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"There are two modes of running calibration: from a sky model or self-calibration. These two modes differ only in how they obtain the model visibilities. In the sky model mode, the visibilities are predicted from the --model file, whilst the self-calibration mode uses the existing MODEL_DATA column as its model (which has usually been populated during an earlier imaging round).","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"Self-calibration is the default mode, unless a sky model is provided by passing the --model parameter.","category":"page"},{"location":"#Options-1","page":"MWAjl","title":"Options","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"usage: calibrate.jl [-m MODEL] [-c CHANWIDTH] [-t TIMEWIDTH]\n                    [--minuv MINUV] [--maxuv MAXUV]\n                    [-a TOLERANCE TOLERANCE] [-i MAX-ITERATIONS]\n                    [--apply-beam] [--datacolumn DATACOLUMN]\n                    [--modelcolumn MODELCOLUMN] [--nbatch NBATCH]\n                    [--gpu] [--verbose] [--debug] [-h] mset solution\n\nCalibrate Murchison Widefield Array (MWA) observations. See\nhttps://torrance.github.io/MWAjl/\n\npositional arguments:\n  mset                  The path to the CASA Measurement Set to be\n                        calibrated.\n  solution              The output solution file name and path. e.g.\n                        folder/to/go/solutions.bin\n\noptional arguments:\n  -m, --model MODEL     The path to the model file (aoskymodel 1.2\n                        format). If absent, will use the --modelcolumn\n                        column (e.g. during self-calibration).\n  -c, --chanwidth CHANWIDTH\n                        Find calibration solutions for blocks of\n                        channels of --chanwidth. Set to 0 to find a\n                        single solution for all channels. Larger\n                        values may provide more signal and aid in\n                        finding a better calibration solution but at\n                        the expense of ignoring frequency-dependenct\n                        changes to the calibration solution. (type:\n                        Int64, default: 1)\n  -t, --timewidth TIMEWIDTH\n                        Find calibrations solutions for blocks of\n                        timesteps of --timewidth. Defaults to 0, which\n                        implies an infinite time width. The duration\n                        of a timestep depends on the resolution of the\n                        Measurement Set and any averaging in time that\n                        may have be performed. e.g. A 2 minute\n                        observation with time resolution 4 s will have\n                        30 timesteps; setting --timewidth 10 will\n                        result in 3 independent solutions in time.\n                        (type: Int64, default: 0)\n  --minuv MINUV         Exclude baselines shorter than this length\n                        from affecting calibration solution (metres).\n                        (type: Float64, default: 0.0)\n  --maxuv MAXUV         Exclude baselines longer than this length from\n                        affecting calibration solutions (metres).\n                        (type: Float64, default: 9.0e99)\n  -a, --tolerance TOLERANCE TOLERANCE\n                        Determines whether a particular calibration\n                        solution has converged. Consists of two\n                        values: mininum accuracy and stopping\n                        accuracy. These two values determine whether\n                        1) a solution has sufficiently converged that\n                        we can accept its answer and 2) whether it has\n                        converged enough that we may stop prior to\n                        reaching --max-iterations. These values are\n                        tested after each iteration by comparing the\n                        magnitude difference between the current\n                        solution and prior solution. (type: Float64,\n                        default: [1.0e-5, 1.0e-8])\n  -i, --max-iterations MAX-ITERATIONS\n                        The maximum number of iterations allowed when\n                        solving for a single solution unit (i.e. for a\n                        given channel and time block). Usually a good\n                        solution can be found in 10-20 iterations. If\n                        you consistently hit the default limit,\n                        consider relaxing the --tolerance stopping\n                        accuracy. Higher --max-iteration values than\n                        the default are of dubious benefit. (type:\n                        Int64, default: 50)\n  --apply-beam          Apply the MWA beam during model prediction to\n                        correct model flux values from their true\n                        values to their apparent values. The beam is\n                        calculated in full polarization for each\n                        timestep and for each coarse channel.\n  --datacolumn DATACOLUMN\n                        The uncalibrated data column in the\n                        Measurement Set. Case sensitive. (default:\n                        \"DATA\")\n  --modelcolumn MODELCOLUMN\n                        The model data column in the Measurement Set\n                        that is used when --model is not provided.\n                        Case sensitive. (default: \"MODEL_DATA\")\n  --nbatch NBATCH       When reading from --datacolumn and\n                        --modelcolumn, this parameter specifies how\n                        many --chanwidth by --timewidth arrays to\n                        read. This parameter only affects performance\n                        and memory usage. Ideally, this needs to be\n                        large enough so that calibration workers\n                        aren't waiting on data to be read from disk,\n                        but not so large that too long is spent\n                        waiting at the start of the program for the\n                        calibration workers to begin work. Reducing\n                        this value will reduce maximum memory usage\n                        proportionally. Default (0) sets this to 200 /\n                        --chanwidth. (type: Int64, default: 0)\n  --gpu                 Use GPU acceleration for model prediction.\n                        Requires a CUDA capable graphics card and\n                        associated CUDA drivers.\n  --verbose             Print logging information about what calibrate\n                        is doing.\n  --debug               Print lots more logging information about what\n                        calibrate is doing.\n  -h, --help            show this help message and exit","category":"page"},{"location":"#When-to-use-minuv-and-maxuv-1","page":"MWAjl","title":"When to use --minuv and --maxuv","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"These two parameters allow you to exclude baselines by their length (metres) from being used to form calibration solutions. That length is the distance between the antennas in 3D space; it is not, for example, a projection onto a uv plane based on the current phase centre, and so will not take into account foreshortening effects.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"The primary reason to use these parameters is when using an incomplete model of the sky (which is always the case!) that might be insensitive to large scale emission features or might be lacking in resolution.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"For example the GLEAM catalogue is commonly used to calibrate MWA observations. The catalogue does not include large scale Galactic emission or supernova remnants. Since these features are of large angular extent, most of their power will be detected on the short baselines. On the other hand, GLEAM used the MWA Phase I array which had a maximum baseline length of just a few kilometres; some of the apparent 'point sources' in GLEAM may actually be resolved to multiple sources in the Phase II array. We can therefore set --minuv 100 and --maxuv 2600 (as an example only!) to use baselines in this interval since it is only in this range that our skymodel is fairly accurate.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"On the other hand, these parameters will exclude data and so make it harder for calibrate to find a good solution amongst all the visibility noise.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"Note also that one set of values might be appropriate when calibrating using a skymodel (e.g. GLEAM), but that another set of values might be appropriate when self-calibrating. In the latter case, it would usually make sense to not impose a --maxuv cutoff at all.","category":"page"},{"location":"#Understanding-tolerance-1","page":"MWAjl","title":"Understanding --tolerance","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"The --tolerance parameter is used to define the convergence of a solution. It is a measure of how much the solution is changing between calibration iterations, and it controls when calibrate thinks what it's found has settled down to a stable value and is 'good enough'. A smaller tolerance indicates a higher degree of required stability of the solution.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"The parameter accepts two values: min-accuracy and stopping-accuracy. If calibrate reaches a stablity between calibration iterations that is smaller than stopping-accuracy, it stops immediately and accepts the solution. However, if by the time calibrate reaches the --max-iterations parameter and the stability is less than min-accuracy, then we will also accept this as a valid solution. If the solution hasn't settled down even to this level of stability, we mark it as failed.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"It's important to note there is a tradeoff between the performance of calibrate and --tolerance. Very low values of --tolerance may force calibrate to consistently hit --max-iterations, without appreciably increasing the quality of the calibration solution.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"For initial calibration (i.e. using --model, which is only a rough and incomplete skymodel), relaxed values of tolerance such as --tolerance 1E-5 1E-6 are recommended. Self-calibration typically can reach much higher stability quite quickly, and values such as --tolerance 1E-5 1E-8 are good.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"If you're consistently hitting the --max-iterations threshold, consider whether your --tolerance is too low. A good solution can usually be reached in only 10-20 iterations.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"The stability value inherits its definition from the original calibrate and is calculated as follows. Each iteration of the Mitchcal/Stefcal algorithm provides a new calibration solution J4 textNANTS. This solution is a 4 x NANTS matrix, where we have a solution for each of the NANTS (e.g. 128) antennas, and for each of the 4 instrumental polarisations. Now, we take the prior solution J_1 and next proposed solution J_2 and we calculate the squared Eucliden distance (elementwise) between the two solutions, Delta = J_1 - J_2^2. Then we find the mean value of this distance for each of the four instrumental polarisations across all antennas (i.e. the mean of each row of Delta). Finally, the stability is defined as the maximum of these four values. That is the stability S is defined as (using 1-indexed notation):","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"S = textmax(textmean(Delta textaxis=2))","category":"page"},{"location":"#Managing-memory-usage-1","page":"MWAjl","title":"Managing memory usage","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"There are three parameters that affect how calibrate uses memory. When calibrate runs, it independently calibrates chunks of visibility data that are --timewidth long in duration (measured in timesteps, not seconds) and --chanwidth wide in frequency space (measured in channels). And calibrate reads from disk --nbatch chunks of this data at once.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"--nbatch is the first option you should change if you want to reduce memory usage. It defaults to --nbatch 200 which means it reads in 200 chunks of visibility data that are --timewidth by --chanwidth in size. You can reduce memory usage by half by simply setting --nbatch 100. Note that --nbatch is a performance optimization: it speeds up performance to read more than just a single channel at a time; it is also faster to send a large array of data to the GPU for prediction rather than multiple small arrays; and prefetching lots of data helps keep the calibration workers from becoming idle. If --nbatch gets so small that calibration workers routinely end up idle, then performance will start to suffer.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"The other two parameters are --timewidth and --chanwidth. The default values are --timewidth 0 which corresponds to all timesteps and --chanwidth 1 which corresponds to a single channel. However, it may be desirable to increase signal by setting --chanwidth 2, for example, and this will double the size of the data in memory. Or, perhaps, you think that a calibration solution varies across the 30 timesteps and instead choose to set --timewidth 10 so that you have 3 separate solutions in time; this will reduce memory usage by 3 times. If you're feeling crazy, setting --timewidth 0 and --chanwidth 0 will force calibrate to attempt to find a single solution for all antennas in time and frequency, and will result in the entire Measurement Set being read into memory.","category":"page"},{"location":"#Performance-notes-1","page":"MWAjl","title":"Performance notes","text":"","category":"section"},{"location":"#Expected-runtime-1","page":"MWAjl","title":"Expected runtime","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"On my own (slightly underpowered, 4/8 core, 64 Gb memory) desktop, the following table gives a rough idea of how long it should take to calibrate a 2 minutes MWA observation (128 tiles):","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"GPU Disk type Components Time\nYes SSD 201 1m40s\nYes SSD 1028 4m40s\nNo SSD 201 6m36s\nNo SSD 1028 24m50s\nn/a SSD selfcal 1m40s\nn/a HDD selfcal 2m30s","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"Of course, these are only approximate values for my own desktop machine and are a snapshot in time. But they should indicate what you should roughly expect, and whether you're encountering slower than expected results.","category":"page"},{"location":"#Model-sources-1","page":"MWAjl","title":"Model sources","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"As can be seen above, performance suffers as the number of sources in --model increases. This is because each source (actually, each component - a single source may be comprised of multiple components) has to be added to the visibilities by way of direct Fourier transform. The computational cost of visibility prediction scales linearly with the number of sources.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"Often, it is not necessary to have a large number of sources. The vast majority of flux in the MWA field of view is often produced by just a handful of sources, and it's usually quite sufficient to calibrate with a model of just 100-200 sources to arrive at a good, initial calibration. The second self-calibration step can take you the rest of the way.","category":"page"},{"location":"#GPU-acceleration-1","page":"MWAjl","title":"GPU acceleration","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"GPU acceleration is used to do the prediction step, that is, turning a --model file into a set of model visibilities. The performance benefit of this varies between computers, but on my own computer I see ~6x speed up by using the GPU as opposed to my 4 cores (8 hyperthreads). This factor also depends on how many components make up your model.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"Note that for self-calibration the GPU is not used at all. As it turned out, the actual calibration step is currently very fast on a CPU, very awkward to perform on a GPU due to a reduction step, and by far the least slowest part of running calibrate.","category":"page"},{"location":"#IO-issues-1","page":"MWAjl","title":"IO issues","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"A significant bottleneck of calibrate is reading data from disk. calibrate uses the CasaCore library to read visibility data that is in the Measurement Set format. The --nbatch option controls how we read data from the Measurement Set, but usually we read a handful of channels at a time (as opposed all channels) to reduce overall memory usage, and this data is not contiguous on disk. For a hard disk drive (i.e. spinning platters), the extra time associated with seeking can add overhead. And on non-local storage such as in a supercomputing cluster, the time spent reading from disk may be the most significant factor in the performance of calibrate.","category":"page"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"Additionally, even when the Measurement Set is stored entirely in memory, there is still some overhead associated with CasaCore itself. For example, on my system it takes 5 s to read the first 100 channels from a Measurement Set that is stored in a tmpfs. It is certainly worth investigating with alternative storages such as HDF5 suffer from the same overhead.","category":"page"},{"location":"#Todo:-1","page":"MWAjl","title":"Todo:","text":"","category":"section"},{"location":"#","page":"MWAjl","title":"MWAjl","text":"explain –tolerance, and recommended settings\nmemory requirements, and mitigations with –timewidth and –chanwidth and –nbatch\nwhat does GPU acceleration do?\ndocument stefcal\nformat of solution.bin files","category":"page"}]
}
